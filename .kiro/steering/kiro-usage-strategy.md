# Kiro Usage Strategy - Winning the Hackathon

## Our Competitive Edge
We're not just using Kiro - we're showcasing it as the ideal development partner for building reusable, production-ready systems.

## Vibe Coding Strategy
Use conversational development for:
- **Rapid prototyping** - "Create a dark-themed card component with hover glitch effect"
- **Refactoring** - "Extract this form logic into a reusable hook"
- **Bug fixes** - "The date picker isn't respecting the theme, fix it"
- **Documentation** - "Add JSDoc comments explaining the entity generation system"

Key insight: Vibe coding excels at creative UI work and quick iterations.

## Spec-Driven Development
Use specs for:
- **Core entity system** - The heart of the skeleton needs precision
- **Theme engine** - Complex state management and CSS variable injection
- **Auth flow** - Security-critical, needs careful implementation
- **Form generator** - Complex logic with many edge cases

Structure specs with:
1. Clear requirements section
2. Technical approach
3. Implementation tasks broken into small chunks
4. Acceptance criteria

## Agent Hooks
Automate repetitive workflows:

### Hook 1: Entity Generator
**Trigger**: When a new entity config file is created
**Action**: Generate corresponding:
- TypeScript types
- List page component
- Form component
- API routes
- Add to navigation config

### Hook 2: Theme Validator
**Trigger**: On save of theme files
**Action**: 
- Check contrast ratios
- Validate CSS variable names
- Run visual regression tests
- Update theme documentation

### Hook 3: Component Documentation
**Trigger**: When component file is saved
**Action**:
- Ensure JSDoc comments exist
- Generate props table for README
- Check for accessibility attributes

### Hook 4: Pre-commit Quality
**Trigger**: Manual (before commits)
**Action**:
- Run TypeScript checks
- Format with Prettier
- Check for console.logs
- Validate all imports resolve

## Steering Documents
Our steering docs guide Kiro's behavior:

1. **project-architecture.md** (always included)
   - Core tech decisions
   - Folder structure
   - Naming conventions

2. **kiro-usage-strategy.md** (this file, always included)
   - How we use Kiro features
   - Development workflows

3. **ui-design-system.md** (included when working on UI)
   - fileMatch: "*.tsx", "*.css"
   - Design tokens, spacing, typography
   - Spooky animation guidelines

4. **entity-system-guide.md** (included when working on entities)
   - fileMatch: "*entity*", "*config*"
   - How entity generation works
   - Extension patterns

## MCP Integration Ideas
Extend Kiro's capabilities:

1. **Appwrite MCP** - Direct integration with Appwrite API
   - Query collections during development
   - Test auth flows
   - Manage permissions

2. **Design System MCP** - Custom tool for our theme system
   - Generate color palettes
   - Test contrast ratios
   - Preview animations

3. **Documentation MCP** - Auto-generate docs
   - Component API docs
   - Entity configuration examples
   - Setup guides

## Demo Video Strategy
Show judges:
1. **Vibe coding** (30s) - Quick UI component creation with natural language
2. **Spec execution** (45s) - Watch Kiro implement the entity system from spec
3. **Hook automation** (30s) - Trigger entity generator, show auto-generated code
4. **Both apps running** (45s) - Side-by-side: esports vs clinic, same skeleton
5. **Developer experience** (30s) - How easy it is to create a new app from skeleton

## Submission Write-up Outline
Structure our Kiro usage explanation:

### Vibe Coding
- Used for 70% of UI components
- Most impressive: "Generated the entire glitch animation system with theme variants in one conversation"
- Showed Kiro examples of spooky UI, it understood the aesthetic

### Specs
- Entity system spec: 15 tasks, all implemented correctly
- Theme engine spec: Complex CSS variable management
- Comparison: Specs gave us confidence in core systems, vibe coding gave us speed in UI

### Hooks
- 4 hooks created, saved ~8 hours of repetitive work
- Entity generator hook is the star - creates 5 files from one config

### Steering
- 4 steering docs kept Kiro aligned on architecture
- Conditional steering for UI work ensured consistent design language

### MCP
- Custom Appwrite MCP let us test auth flows without leaving Kiro
- Saved time on API documentation lookups

## Success Metrics
Track to show judges:
- Lines of code generated by Kiro vs manual: aim for 80%+ Kiro
- Time saved by hooks: document before/after
- Spec vs vibe coding: show both approaches worked for different needs
- Code quality: zero TypeScript errors, all components documented
